"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkascii_game"] = self["webpackChunkascii_game"] || []).push([["src_levels_paint_mjs"],{

/***/ "./src/components/ascii-canvas/index.mjs":
/*!***********************************************!*\
  !*** ./src/components/ascii-canvas/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLORS\": () => (/* binding */ COLORS),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst COLORS = {\n  TRANSPARENT: -1,\n  PINK: 0,\n  WHITE: 1,\n  LIGHT_BLUE: 2,\n  DARK_BLUE: 3,\n  NAVY: 4,\n}\n\n// I think this needs to be expanded to support colour / icon palettes\nconst COLOR_CLASSES = [\n  'pink',\n  'white',\n  'light-blue',\n  'dark-blue',\n  'navy',\n]\n\nconst BACKGROUND_COLOR_CLASSES = [\n  'pink-background',\n  'white-background',\n  'light-blue-background',\n  'dark-blue-background',\n  'navy-background',\n]\n\n// Add logic so you can't draw outside the canvas.\nfunction AsciiContext (canvas) {\n  this.canvas = canvas\n  this.fill = { character: 'x', color: COLORS.WHITE, backgroundColor: COLORS.NAVY }\n  this.stroke = { character: '-', color: COLORS.PINK, backgroundColor: COLORS.NAVY }\n  this.setFill = (character, color, backgroundColor) => {\n    this.fill = { character, color, backgroundColor }\n  }\n  this.setStroke = (character, color, backgroundColor) => {\n    this.stroke = { character, color, backgroundColor }\n  }\n  this.clearRect = (x, y, w, h) => {\n    const minWidth = Math.max(x, 0)\n    const minHeight = Math.max(y, 0)\n    const maxWidth = Math.min(x + w, this.canvas.width)\n    const maxHeight = Math.min(y + h, this.canvas.height)\n\n    for (let i = minWidth; i < maxWidth; i++) {\n      for (let j = minHeight; j < maxHeight; j++) {\n        this.canvas.data[j][i] = { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY }\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.strokeRect = (x, y, w, h) => {\n    if (x > -1) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][x] = this.stroke\n      }\n    }\n\n    if (x + w <= this.canvas.width) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][x + w - 1] = this.stroke\n      }\n    }\n\n    if (y > -1) {\n      for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n        this.canvas.data[y][i] = this.stroke\n      }\n    }\n\n    if (y + h <= this.canvas.height) {\n      for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n        this.canvas.data[y + h - 1][i] = this.stroke\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.fillRect = (x, y, w, h) => {\n    for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][i] = this.fill\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.setPixel = (x, y, character) => {\n    this.canvas.data[y][x] = character\n    this.canvas.changed = true\n  }\n\n  // Basic image format\n  this.drawImage = (asciiImage, x, y) => {\n    asciiImage.data.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character,\n            color: asciiImage.color,\n            backgroundColor: COLORS.NAVY,\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n\n  // Image format that supports character, foreground color & background color\n  this.drawImage2 = (asciiImage, x, y) => {\n    asciiImage.data.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character.character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character: character.character,\n            color: character.color,\n            backgroundColor: character.backgroundColor\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n\n  // Image format that supports animations\n  // Perhaps this should instead JUST take in the frame.\n  // That way the animation could be a layer higher.\n  this.drawImage3 = (asciiImage, x, y, frameIndex) => {\n    const imageData = asciiImage.frames[frameIndex].data\n    imageData.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character.character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character: character.character,\n            color: character.color,\n            backgroundColor: character.backgroundColor\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n}\n\nconst create2DArray = (width, height, value) => {\n  const arr = []\n  for (let y = 0; y < height; y++) {\n    arr[y] = []\n    for (let x = 0; x < width; x++) {\n      arr[y][x] = value\n    }\n  }\n  return arr\n}\n\nconst fromAsciiToString = (ascii) => {\n  return ascii.map(\n    (row, y) => row.map((item, x) => {\n      return `<span data-x=\"${x}\" data-y=\"${y}\" class=\"${COLOR_CLASSES[item.color]}${item.backgroundColor === COLORS.TRANSPARENT ? '' : ` ${BACKGROUND_COLOR_CLASSES[item.backgroundColor]}`}\">${item.character}</span>`\n    }).join('')\n  ).join('\\n')\n}\n\n// Other places should be updated to use width rather than w or visa versa.\nfunction AsciiCanvas (container, width, height) {\n  this.changed = false\n  this.width = width\n  this.height = height\n  this.data = create2DArray(this.width, this.height, { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY })\n  this.setSize = (w, h) => {\n    this.width = w\n    this.height = h\n    this.data = create2DArray(this.width, this.height, { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY })\n    this.updateDom()\n  }\n  this.context = new AsciiContext(this)\n  this.getContext = () => this.context\n  this.container = container\n  this.preNode = document.createElement('pre')\n  this.updateDom = () => {\n    if (this.changed) {\n      this.preNode.innerHTML = fromAsciiToString(this.data)\n      this.changed = false\n    }\n  }\n  this.updateDom()\n  this.container.appendChild(this.preNode)\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AsciiCanvas);\n\n\n//# sourceURL=webpack://ascii-game/./src/components/ascii-canvas/index.mjs?");

/***/ }),

/***/ "./src/levels/paint.mjs":
/*!******************************!*\
  !*** ./src/levels/paint.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/ascii-canvas/index.mjs */ \"./src/components/ascii-canvas/index.mjs\");\n\n\nconst $ = (id) => document.getElementById(id)\n\nconst brushInput = $('brush-input')\nconst colorInput = $('brush-color-input')\nconst backgroundColorInput = $('brush-background-color-input')\nconst pencilButton = $('pencil-button')\nconst eraserButton = $('eraser-button')\nconst canvasWidthInput = $('canvas-width-input')\nconst canvasHeightInput = $('canvas-height-input')\n\nconst TOOL = {\n  PENCIL: 'pencil',\n  ERASER: 'eraser',\n}\n\nlet tool = TOOL.PENCIL\nlet brush = {\n  character: 'x',\n  color: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.WHITE,\n  backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.NAVY,\n}\n\nlet CANVAS_WIDTH = 80\nlet CANVAS_HEIGHT = 40\n\nlet filename = 'sprite'\n\nconst filenameInput = $('filename-input')\n\nfilenameInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    filename = e.target.value\n  }\n})\n\nconst downloadButton = $('download-button')\ndownloadButton.addEventListener('click', () => {\n  downloadButton.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(drawingImage2)))\n  downloadButton.setAttribute('download', `${filename}.json`)\n})\n\ncanvasWidthInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    CANVAS_WIDTH = parseInt(e.target.value)\n    asciiCanvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT)\n    drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n  }\n})\n\ncanvasHeightInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    CANVAS_HEIGHT = parseInt(e.target.value)\n    asciiCanvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT)\n    drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n  }\n})\n\nbrushInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    brush.character = e.target.value\n  }\n})\n\ncolorInput.addEventListener('input', e => {\n  brush.color = e.target.value\n})\n\nbackgroundColorInput.addEventListener('input', e => {\n  brush.backgroundColor = e.target.value\n})\n\npencilButton.addEventListener('click', () => {\n  tool = TOOL.PENCIL\n})\n\neraserButton.addEventListener('click', () => {\n  tool = TOOL.ERASER\n})\n\nconst canvasContainer = $('game')\n\nconst create2DArray = (width, height, value) => {\n  const arr = []\n  for (let y = 0; y < height; y++) {\n    arr[y] = []\n    for (let x = 0; x < width; x++) {\n      arr[y][x] = value\n    }\n  }\n  return arr\n}\n\n// const drawingImage = {\n//   data: create2DArray(CANVAS_WIDTH, CANVAS_HEIGHT, { character: ' ', color: COLORS.WHITE, backgroundColor: COLORS.TRANSPARENT }),\n//   w: CANVAS_WIDTH,\n//   h: CANVAS_HEIGHT,\n//   color: COLORS.WHITE,\n// }\n\nconst createBlankFrame = (w, h) => {\n  return {\n    data: create2DArray(\n      w,\n      h,\n      {\n        character: ' ',\n        color: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.WHITE,\n        backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.TRANSPARENT,\n      },\n    ),\n  }\n}\n\nconst createBlankImage = (w, h) => {\n  return {\n    frames: [\n      createBlankFrame(w, h),\n    ],\n    w,\n    h,\n  }\n}\n\nconst addFrameToImage = (image, w, h) => {\n  image.frames.push(createBlankFrame(w, h))\n}\n\nlet drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n\nlet frame = 0\nconst frameInput = $('frame-input')\nconst addFrameButton = $('add-frame-button')\n\nframeInput.addEventListener('change', e => {\n  if (e.target.value !== '') {\n    frame = parseInt(e.target.value)\n  }\n})\n\naddFrameButton.addEventListener('click', () => {\n  addFrameToImage(drawingImage2, CANVAS_WIDTH, CANVAS_HEIGHT)\n  frameInput.max++\n})\n\nlet drawing = false\ncanvasContainer.addEventListener('mousedown', e => {\n  drawing = true\n  const x = e.target.dataset.x\n  const y = e.target.dataset.y\n\n  if (x && y) {\n    const imageData = drawingImage2.frames[frame].data\n    imageData[parseInt(y)][parseInt(x)] = tool === TOOL.PENCIL ? { character: brush.character, color: brush.color, backgroundColor: brush.backgroundColor } : { character: ' ', color: brush.color, backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.TRANSPARENT }\n  }\n})\n\ncanvasContainer.addEventListener('mousemove', e => {\n  if (drawing) {\n    const x = e.target.dataset.x\n    const y = e.target.dataset.y\n\n    if (x && y) {\n      const imageData = drawingImage2.frames[frame].data\n      imageData[parseInt(y)][parseInt(x)] = tool === TOOL.PENCIL ? { character: brush.character, color: brush.color, backgroundColor: brush.backgroundColor } : { character: ' ', color: brush.color, backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.TRANSPARENT }\n    }\n  }\n})\n\ncanvasContainer.addEventListener('mouseup', e => {\n  drawing = false\n})\n\nconst asciiCanvas = new _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvasContainer, CANVAS_WIDTH, CANVAS_HEIGHT)\nconst context = asciiCanvas.getContext()\n\nlet lastTime = (new Date()).getTime()\nlet currentTime = 0\nlet dt = 0\n\nconst init = async () => {\n  lastTime = (new Date()).getTime()\n  currentTime = 0\n  dt = 0\n\n  window.requestAnimationFrame(update)\n}\n\nconst update = () => {\n  window.requestAnimationFrame(update)\n\n  currentTime = (new Date()).getTime()\n  dt = (currentTime - lastTime) / 1000\n\n  render()\n\n  lastTime = currentTime\n}\n\nconst render = () => {\n  context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)\n\n  context.drawImage3(drawingImage2, 0, 0, frame)\n  asciiCanvas.updateDom()\n}\n\ninit().then(() => {\n\n}).catch(() => {\n\n})\n\n\n//# sourceURL=webpack://ascii-game/./src/levels/paint.mjs?");

/***/ })

}]);