"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkascii_game"] = self["webpackChunkascii_game"] || []).push([["src_pages_paint_mjs"],{

/***/ "./src/components/ascii-canvas/index.mjs":
/*!***********************************************!*\
  !*** ./src/components/ascii-canvas/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"COLORS\": () => (/* binding */ COLORS),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst COLORS = {\n  TRANSPARENT: -1,\n  PINK: 0,\n  WHITE: 1,\n  LIGHT_BLUE: 2,\n  DARK_BLUE: 3,\n  NAVY: 4,\n}\n\n// I think this needs to be expanded to support colour / icon palettes\nconst COLOR_CLASSES = [\n  'pink',\n  'white',\n  'light-blue',\n  'dark-blue',\n  'navy',\n]\n\nconst BACKGROUND_COLOR_CLASSES = [\n  'pink-background',\n  'white-background',\n  'light-blue-background',\n  'dark-blue-background',\n  'navy-background',\n]\n\n// Add logic so you can't draw outside the canvas.\nfunction AsciiContext (canvas) {\n  this.canvas = canvas\n  this.fill = { character: 'x', color: COLORS.WHITE, backgroundColor: COLORS.NAVY }\n  this.stroke = { character: '-', color: COLORS.PINK, backgroundColor: COLORS.NAVY }\n  this.setFill = (character, color, backgroundColor) => {\n    this.fill = { character, color, backgroundColor }\n  }\n  this.setStroke = (character, color, backgroundColor) => {\n    this.stroke = { character, color, backgroundColor }\n  }\n  this.clearRect = (x, y, w, h) => {\n    const minWidth = Math.max(x, 0)\n    const minHeight = Math.max(y, 0)\n    const maxWidth = Math.min(x + w, this.canvas.width)\n    const maxHeight = Math.min(y + h, this.canvas.height)\n\n    for (let i = minWidth; i < maxWidth; i++) {\n      for (let j = minHeight; j < maxHeight; j++) {\n        this.canvas.data[j][i] = { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY }\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.strokeRect = (x, y, w, h) => {\n    if (x > -1) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][x] = this.stroke\n      }\n    }\n\n    if (x + w <= this.canvas.width) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][x + w - 1] = this.stroke\n      }\n    }\n\n    if (y > -1) {\n      for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n        this.canvas.data[y][i] = this.stroke\n      }\n    }\n\n    if (y + h <= this.canvas.height) {\n      for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n        this.canvas.data[y + h - 1][i] = this.stroke\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.fillRect = (x, y, w, h) => {\n    for (let i = Math.max(x, 0); i < Math.min(x + w, this.canvas.width); i++) {\n      for (let j = Math.max(y, 0); j < Math.min(y + h, this.canvas.height); j++) {\n        this.canvas.data[j][i] = this.fill\n      }\n    }\n    this.canvas.changed = true\n  }\n\n  this.setPixel = (x, y, character) => {\n    this.canvas.data[y][x] = character\n    this.canvas.changed = true\n  }\n\n  // Basic image format\n  this.drawImage = (asciiImage, x, y) => {\n    asciiImage.data.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character,\n            color: asciiImage.color,\n            backgroundColor: COLORS.NAVY,\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n\n  // Image format that supports character, foreground color & background color\n  this.drawImage2 = (asciiImage, x, y) => {\n    asciiImage.data.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character.character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character: character.character,\n            color: character.color,\n            backgroundColor: character.backgroundColor\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n\n  // Image format that supports animations\n  // Perhaps this should instead JUST take in the frame.\n  // That way the animation could be a layer higher.\n  this.drawImage3 = (asciiImage, x, y, frameIndex) => {\n    const imageData = asciiImage.frames[frameIndex].data\n    imageData.forEach((row, i) => {\n      row.forEach((character, j) => {\n        if (y + i > -1 && y + i < this.canvas.height && x + j > -1 && x + j < this.canvas.width && character.character !== ' ') {\n          this.canvas.data[y + i][x + j] = {\n            character: character.character,\n            color: character.color,\n            backgroundColor: character.backgroundColor\n          }\n        }\n      })\n    })\n    this.canvas.changed = true\n  }\n}\n\nconst create2DArray = (width, height, value) => {\n  const arr = []\n  for (let y = 0; y < height; y++) {\n    arr[y] = []\n    for (let x = 0; x < width; x++) {\n      arr[y][x] = value\n    }\n  }\n  return arr\n}\n\nconst fromAsciiToString = (ascii) => {\n  return ascii.map(\n    (row, y) => row.map((item, x) => {\n      return `<span data-x=\"${x}\" data-y=\"${y}\" class=\"${COLOR_CLASSES[item.color]}${item.backgroundColor === COLORS.TRANSPARENT ? '' : ` ${BACKGROUND_COLOR_CLASSES[item.backgroundColor]}`}\">${item.character}</span>`\n    }).join('')\n  ).join('\\n')\n}\n\n// Other places should be updated to use width rather than w or visa versa.\nfunction AsciiCanvas (container, width, height) {\n  this.changed = false\n  this.width = width\n  this.height = height\n  this.data = create2DArray(this.width, this.height, { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY })\n  this.setSize = (w, h) => {\n    this.width = w\n    this.height = h\n    this.data = create2DArray(this.width, this.height, { character: ' ', color: COLORS.PINK, backgroundColor: COLORS.NAVY })\n    this.updateDom()\n  }\n  this.context = new AsciiContext(this)\n  this.getContext = () => this.context\n  this.container = container\n  this.preNode = document.createElement('pre')\n  this.updateDom = () => {\n    if (this.changed) {\n      this.preNode.innerHTML = fromAsciiToString(this.data)\n      this.changed = false\n    }\n  }\n  this.updateDom()\n  this.container.appendChild(this.preNode)\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AsciiCanvas);\n\n\n//# sourceURL=webpack://ascii-game/./src/components/ascii-canvas/index.mjs?");

/***/ }),

/***/ "./src/config.mjs":
/*!************************!*\
  !*** ./src/config.mjs ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DIRECTION\": () => (/* binding */ DIRECTION),\n/* harmony export */   \"characters\": () => (/* binding */ characters),\n/* harmony export */   \"colors\": () => (/* binding */ colors)\n/* harmony export */ });\nconst DIRECTION = {\n  LEFT: -1,\n  RIGHT: 1,\n}\n\nconst colors = [\n  '#140c1c',\n  '#442434',\n  '#30346d',\n  '#4e4a4e',\n  '#854c30',\n  '#346524',\n  '#d04648',\n  '#757161',\n  '#597cce',\n  '#d27c2c',\n  '#8595a1',\n  '#6daa2c',\n  '#d2aa99',\n  '#6dc2ca',\n  '#dad45e',\n  '#deeed6',\n]\n\nconst characters = [\n  '☺',\n  '☻',\n  '♥',\n  '♦',\n  '♣',\n  '♠',\n  '•',\n  '◘',\n  '○',\n  '◙',\n  '♂',\n  '♀',\n  '♪',\n  '♫',\n  '☼',\n  '►',\n  '◄',\n  '↕',\n  '‼',\n  '¶',\n  '§',\n  '▬',\n  '↨',\n  '↑',\n  '↓',\n  '→',\n  '←',\n  '∟',\n  '↔',\n  '▲',\n  '▼',\n  '!',\n  '\"',\n  '#',\n  '$',\n  '%',\n  '&',\n  '\\'',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '<',\n  '=',\n  '>',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '\\\\',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  '⌂',\n  'Ç',\n  'ü',\n  'é',\n  'â',\n  'ä',\n  'à',\n  'å',\n  'ç',\n  'ê',\n  'ë',\n  'è',\n  'ï',\n  'î',\n  'ì',\n  'Ä',\n  'Å',\n  'É',\n  'æ',\n  'Æ',\n  'ô',\n  'ö',\n  'ò',\n  'û',\n  'ù',\n  'ÿ',\n  'Ö',\n  'Ü',\n  '¢',\n  '£',\n  '¥',\n  '₧',\n  'ƒ',\n  'á',\n  'í',\n  'ó',\n  'ú',\n  'ñ',\n  'Ñ',\n  'ª',\n  'º',\n  '¿',\n  '⌐',\n  '¬',\n  '½',\n  '¼',\n  '¡',\n  '«',\n  '»',\n  '░',\n  '▒',\n  '▓',\n  '│',\n  '┤',\n  '╡',\n  '╢',\n  '╖',\n  '╕',\n  '╣',\n  '║',\n  '╗',\n  '╝',\n  '╜',\n  '╛',\n  '┐',\n  '└',\n  '┴',\n  '┬',\n  '├',\n  '─',\n  '┼',\n  '╞',\n  '╟',\n  '╚',\n  '╔',\n  '╩',\n  '╦',\n  '╠',\n  '═',\n  '╬',\n  '╧',\n  '╨',\n  '╤',\n  '╥',\n  '╙',\n  '╘',\n  '╒',\n  '╓',\n  '╫',\n  '╪',\n  '┘',\n  '┌',\n  '█',\n  '▄',\n  '▌',\n  '▐',\n  '▀',\n  'α',\n  'ß',\n  'Γ',\n  'π',\n  'Σ',\n  'σ',\n  'µ',\n  'τ',\n  'Φ',\n  'Θ',\n  'Ω',\n  'δ',\n  '∞',\n  'φ',\n  'ε',\n  '∩',\n  '≡',\n  '±',\n  '≥',\n  '≤',\n  '⌠',\n  '⌡',\n  '÷',\n  '≈',\n  '°',\n  '∙',\n  '·',\n  '√',\n  'ⁿ',\n  '²',\n  '■',\n  '□',\n  '▢',\n  '▣',\n  '▤',\n  '▥',\n  '▦',\n  '▧',\n  '▨',\n  '▩',\n  '▪',\n  '▫',\n  '▭',\n  '▮',\n  '▯',\n  '▰',\n  '▱',\n  '▲',\n  '△',\n  '▴',\n  '▵',\n  '▶',\n  '▷',\n  '▸',\n  '▹',\n  '►',\n  '▻',\n  '▼',\n  '▽',\n  '▾',\n  '▿',\n  '◀',\n  '◁',\n  '◂',\n  '◃',\n  '◄',\n  '◅',\n  '◆',\n  '◇',\n  '◈',\n  '◉',\n  '◊',\n  '○',\n  '◌',\n  '◍',\n  '◎',\n  '●',\n  '◐',\n  '◑',\n  '◒',\n  '◓',\n  '◔',\n  '◕',\n  '◖',\n  '◗',\n  '◘',\n  '◙',\n  '◚',\n  '◛',\n  '◜',\n  '◝',\n  '◞',\n  '◟',\n  '◠',\n  '◡',\n  '◢',\n  '◣',\n  '◤',\n  '◥',\n  '◦',\n  '◧',\n  '◨',\n  '◩',\n  '◪',\n  '◫',\n  '◬',\n  '◭',\n  '◮',\n  '◯',\n  '◰',\n  '◱',\n  '◲',\n  '◳',\n  '◴',\n  '◵',\n  '◶',\n  '◷',\n  '◸',\n  '◹',\n  '◺',\n  '◻',\n  '◼',\n  '◽',\n  '◾',\n  '◿',\n]\n\n\n//# sourceURL=webpack://ascii-game/./src/config.mjs?");

/***/ }),

/***/ "./src/pages/paint.mjs":
/*!*****************************!*\
  !*** ./src/pages/paint.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/ascii-canvas/index.mjs */ \"./src/components/ascii-canvas/index.mjs\");\n/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config.mjs */ \"./src/config.mjs\");\n\n\n\nconst $ = (id) => document.getElementById(id)\n\nconst brushInput = $('brush-input')\nconst colorInput = $('brush-color-input')\nconst backgroundColorInput = $('brush-background-color-input')\nconst pencilButton = $('pencil-button')\nconst eraserButton = $('eraser-button')\nconst canvasWidthInput = $('canvas-width-input')\nconst canvasHeightInput = $('canvas-height-input')\n\nconst TOOL = {\n  PENCIL: 'pencil',\n  'FILL': 'fill',\n  ERASER: 'eraser',\n}\n\nlet tool = TOOL.PENCIL\nlet brush = {\n  character: 'x',\n  color: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.WHITE,\n  backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.NAVY,\n}\n\nlet CANVAS_WIDTH = 80\nlet CANVAS_HEIGHT = 40\n\nlet filename = 'sprite'\n\nconst filenameInput = $('filename-input')\n\nfilenameInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    filename = e.target.value\n  }\n})\n\nconst downloadButton = $('download-button')\ndownloadButton.addEventListener('click', () => {\n  downloadButton.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(drawingImage2)))\n  downloadButton.setAttribute('download', `${filename}.json`)\n})\n\ncanvasWidthInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    CANVAS_WIDTH = parseInt(e.target.value)\n    asciiCanvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT)\n    drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n  }\n})\n\ncanvasHeightInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    CANVAS_HEIGHT = parseInt(e.target.value)\n    asciiCanvas.setSize(CANVAS_WIDTH, CANVAS_HEIGHT)\n    drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n  }\n})\n\nbrushInput.addEventListener('input', e => {\n  if (e.target.value !== '') {\n    brush.character = e.target.value\n  }\n})\n\nconst ansiPaletteContainer = $('ansi-palette-container')\n\n_config_mjs__WEBPACK_IMPORTED_MODULE_1__.characters.forEach(character => {\n  const button = document.createElement('button')\n  button.innerText = character\n  button.addEventListener('click', () => {\n    brushInput.value = character\n    brush.character = character\n  })\n  ansiPaletteContainer.appendChild(button)\n})\n\ncolorInput.addEventListener('input', e => {\n  brush.color = e.target.value\n})\n\nbackgroundColorInput.addEventListener('input', e => {\n  brush.backgroundColor = e.target.value\n})\n\npencilButton.addEventListener('click', () => {\n  tool = TOOL.PENCIL\n})\n\nconst fillButton = $('fill-button')\n\nfillButton.addEventListener('click', () => {\n  tool = TOOL.FILL\n})\n\neraserButton.addEventListener('click', () => {\n  tool = TOOL.ERASER\n})\n\nconst canvasContainer = $('game')\n\nconst create2DArray = (width, height, value) => {\n  const arr = []\n  for (let y = 0; y < height; y++) {\n    arr[y] = []\n    for (let x = 0; x < width; x++) {\n      arr[y][x] = value\n    }\n  }\n  return arr\n}\n\n// const drawingImage = {\n//   data: create2DArray(CANVAS_WIDTH, CANVAS_HEIGHT, { character: ' ', color: COLORS.WHITE, backgroundColor: COLORS.TRANSPARENT }),\n//   w: CANVAS_WIDTH,\n//   h: CANVAS_HEIGHT,\n//   color: COLORS.WHITE,\n// }\n\nconst createBlankFrame = (w, h) => {\n  return {\n    data: create2DArray(\n      w,\n      h,\n      {\n        character: ' ',\n        color: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.WHITE,\n        backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.TRANSPARENT,\n      },\n    ),\n  }\n}\n\nconst createBlankImage = (w, h) => {\n  return {\n    frames: [\n      createBlankFrame(w, h),\n    ],\n    w,\n    h,\n  }\n}\n\nconst addFrameToImage = (image, w, h) => {\n  image.frames.push(createBlankFrame(w, h))\n}\n\nlet drawingImage2 = createBlankImage(CANVAS_WIDTH, CANVAS_HEIGHT)\n\nlet frame = 0\nconst frameInput = $('frame-input')\nconst addFrameButton = $('add-frame-button')\n\nframeInput.addEventListener('change', e => {\n  if (e.target.value !== '') {\n    frame = parseInt(e.target.value)\n  }\n})\n\naddFrameButton.addEventListener('click', () => {\n  addFrameToImage(drawingImage2, CANVAS_WIDTH, CANVAS_HEIGHT)\n  frameInput.max++\n})\n\nconst usePencil = (imageData, x, y) => {\n  imageData[y][x] = {\n    character: brush.character,\n    color: brush.color,\n    backgroundColor: brush.backgroundColor,\n  }\n}\n\nconst floodFill = (imageData, x, y, newColor) => {\n  //Get the input which needs to be replaced.\n  const current = imageData[y][x]\n\n  //If the newColor is same as the existing\n  //Then return the original image.\n  if (current === newColor) {\n    return imageData\n  }\n\n  //Other wise call the fill function which will fill in the existing image.\n  fill(imageData, x, y, newColor, current)\n\n  //Return the image once it is filled\n  return imageData\n}\n\nconst fill = (imageData, x, y, newColor, current) => {\n  if(y < 0){\n    return\n  }\n\n  if(x < 0){\n    return\n  }\n\n  if(y > imageData.length - 1){\n    return\n  }\n\n  if(x > imageData[y].length - 1){\n    return\n  }\n\n  // I could do a more precise comparison here in the future.\n  if(JSON.stringify(imageData[y][x]) !== JSON.stringify(current)){\n    return\n  }\n\n  imageData[y][x] = {\n    character: brush.character,\n    color: brush.color,\n    backgroundColor: brush.backgroundColor,\n  }\n\n  fill(imageData, x - 1, y, newColor, current)\n  fill(imageData, x + 1, y, newColor, current)\n  fill(imageData, x, y - 1, newColor, current)\n  fill(imageData, x, y + 1, newColor, current)\n}\n\n\nconst useFill = (imageData, x, y) => {\n  floodFill(imageData, x, y, brush)\n}\n\nconst useEraser = (imageData, x, y) => {\n  imageData[y][x] = {\n    character: ' ',\n    color: brush.color,\n    backgroundColor: _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__.COLORS.TRANSPARENT,\n  }\n}\n\nconst useBrush = (x, y) => {\n  const imageData = drawingImage2.frames[frame].data\n  switch (tool) {\n    case TOOL.PENCIL:\n      usePencil(imageData, x, y)\n      break\n    case TOOL.FILL:\n      useFill(imageData, x, y)\n      break\n    case TOOL.ERASER:\n      useEraser(imageData, x, y)\n      break\n  }\n}\n\nlet drawing = false\ncanvasContainer.addEventListener('mousedown', e => {\n  drawing = true\n  const x = e.target.dataset.x\n  const y = e.target.dataset.y\n\n  if (x && y) {\n    useBrush(parseInt(x), parseInt(y))\n  }\n})\n\ncanvasContainer.addEventListener('mousemove', e => {\n  if (drawing) {\n    const x = e.target.dataset.x\n    const y = e.target.dataset.y\n\n    if (x && y) {\n      useBrush(parseInt(x), parseInt(y))\n    }\n  }\n})\n\ncanvasContainer.addEventListener('mouseup', e => {\n  drawing = false\n})\n\nconst asciiCanvas = new _components_ascii_canvas_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvasContainer, CANVAS_WIDTH, CANVAS_HEIGHT)\nconst context = asciiCanvas.getContext()\n\nlet lastTime = (new Date()).getTime()\nlet currentTime = 0\nlet dt = 0\n\nconst init = async () => {\n  lastTime = (new Date()).getTime()\n  currentTime = 0\n  dt = 0\n\n  window.requestAnimationFrame(update)\n}\n\nconst update = () => {\n  window.requestAnimationFrame(update)\n\n  currentTime = (new Date()).getTime()\n  dt = (currentTime - lastTime) / 1000\n\n  render()\n\n  lastTime = currentTime\n}\n\nconst render = () => {\n  context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)\n\n  context.drawImage3(drawingImage2, 0, 0, frame)\n  asciiCanvas.updateDom()\n}\n\ninit().then(() => {\n\n}).catch(() => {\n\n})\n\n\n//# sourceURL=webpack://ascii-game/./src/pages/paint.mjs?");

/***/ })

}]);